@implements IDisposable
@using System.Diagnostics.CodeAnalysis
@using Drogecode.Knrm.Oefenrooster.Client.Repositories;
@using Drogecode.Knrm.Oefenrooster.Client.Services
@using Drogecode.Knrm.Oefenrooster.Client.Services.Interfaces;
@using Drogecode.Knrm.Oefenrooster.Shared.Models.Configuration;
@if (_newVersionAvailable)
{
    <button type="button" class="btn btn-warning shadow floating-update-button" onclick="window.location.reload()">
        A new version of the application is available. Click here to reload.
    </button>
}

@code {
    [Inject] private IStringLocalizer<UpdateChecker> L { get; set; } = default!;
    [Inject, NotNull] private IJSRuntime? JsRuntime { get; set; }
    [Inject] private ConfigurationRepository ConfigurationRepository { get; set; } = default!;
    [Inject] private NavigationManager Navigation { get; set; } = default!;
    [Inject] private CustomStateProvider AuthenticationStateProvider { get; set; } = default!;
    [Inject] IOfflineService OfflineService { get; set; } = default!;
    [Inject] ISnackbar Snackbar { get; set; } = default!;
    private VersionDetailResponse? _updateDetails;
    private CancellationTokenSource _cls = new();

    private bool _newVersionAvailable = false;

    protected override async Task OnInitializedAsync()
    {
        await RegisterForUpdateAvailableNotification();
    }

    private async Task RegisterForUpdateAvailableNotification()
    {
        await JsRuntime.InvokeAsync<object>(
            identifier: "registerForUpdateAvailableNotification",
            DotNetObjectReference.Create(this),
            nameof(OnUpdateAvailable));
    }

    [JSInvokable(nameof(OnUpdateAvailable))]
    public Task OnUpdateAvailable()
    {
        DebugHelper.WriteLine("New version detected by OnUpdateAvailable()");
        _newVersionAvailable = true;

        StateHasChanged();

        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        while (!_cls.IsCancellationRequested)
        {
            try
            {
                var user = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                _updateDetails = await ConfigurationRepository.NewVersionAvailable();
                if (_updateDetails is not null && (_updateDetails.UpdateVersion != DefaultSettingsHelper.UPDATE_VERSION || _updateDetails.ButtonVersion != DefaultSettingsHelper.BUTTON_VERSION) && _updateDetails.UpdateVersion <= _updateDetails.ButtonVersion)
                {
                    var config = (SnackbarOptions options) =>
                    {
                        options.DuplicatesBehavior = SnackbarDuplicatesBehavior.Prevent;
                        options.RequireInteraction = true;
                        options.Action = L["Click to reload"];
                        options.ActionColor = Color.Inherit;
                        options.Onclick = snackbar =>
                        {
                            Navigation.NavigateTo(Navigation.Uri, true);
                            return Task.CompletedTask;
                        };
                    };
                    Snackbar.Add(L["Update available"], Severity.Warning, configure: config, key: "outdated");
                }

                if (user.User.Identity?.IsAuthenticated is not true)
                    await AuthenticationStateProvider.Logout();
            }
            catch (Exception ex)
            {
                DebugHelper.WriteLine(ex);
            }
            finally
            {
                for (int i = 0; i < 30; i++)
                {
                    if (_cls.IsCancellationRequested)
                        break;
                    await Task.Delay(1000);
                }
            }
        }
    }

    public void Dispose()
    {
        _cls.Cancel();
    }

}